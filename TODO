1. Add expectation value paths/options

   raw_circuit      -> Noise -> observable (property of density matrix or of statevector)
   compiled_circuit -> Noise -> observable
     circuit -> save density matrix at end

    observable_metrics(raw_qiskit, compiled_qiskit, sim_settings):
        raw_qiskit.save_density_matrix()
        compiled_qiskit.save_density_matrix()

        # no noise
        raw ->
        compiled ->
          # if exp value
          statevector from circuit
          # if HOPF/counts of circuit measurement
          - first heavy bitstrings, statevector sim of circuit, counts/filter
          - then statevector sim of circuit, count which are heavy from prior
        # with noise
        raw
        compiled
          # if exp value
          Aer sim, density matrix,
           # if HOPF/counts of circuit measurement
             - first heavy bitstrings, statevector sim of circuit, counts/filter
            - then statevector sim of circuit with noise, count which are heavy from prior

        1. CREATE results type
        2. Consider whether to use decorator vs ABC for registering -- seems its always single function? Better to keep pattern
        3. Cleanup HOPF nested functions, its messy
        4. Add unit tests
        5. Decide on toml schema and validation
        6. Add to runner and results


2. Add documention (the how to's in README)



+2. Example, how to add a compiler
+8. How to add an expectation value observable
+9. How to add a metric observable
+5. Example how to run locally for debug/comparing
----------
4. Example, how to delete results
6. Example how to add/update a benchmark
    When to change the version?
7. How to update compiler versions
----------

------------------
8. Import legacy data
-----------------
4. Add plotter helpers

5. Add PR helper -> do not persist results
   Two types of PRs
    PR in ucc-bench repo (updating something about benchmark code)
      run benchmarks on changest in PR and compare to results for prior commit
    PR in ucc repo (updating something about UCC)
      create a version of this repo that uses pre-release version of UCC (specific hash)
      do the same as above

--- Demo here
3. Add reporter that converts to flat view of performance
6. Add github actions
7. Run in parallel with main repo, then switch when ready


