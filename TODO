1. Add expectation value paths/options

   raw_circuit      -> Noise -> observable (property of density matrix or of statevector)
   compiled_circuit -> Noise -> observable
     circuit -> save density matrix at end

    observable_metrics(raw_qiskit, compiled_qiskit, sim_settings):
        raw_qiskit.save_density_matrix()
        compiled_qiskit.save_density_matrix()

        # no noise
        raw ->
        compiled ->
          # if exp value
          statevector from circuit
          # if HOPF/counts of circuit measurement
          - first heavy bitstrings, statevector sim of circuit, counts/filter
          - then statevector sim of circuit, count which are heavy from prior
        # with noise
        raw
        compiled
          # if exp value
          Aer sim, density matrix,
           # if HOPF/counts of circuit measurement
             - first heavy bitstrings, statevector sim of circuit, counts/filter
            - then statevector sim of circuit with noise, count which are heavy from prior

        1. CREATE results type
        2. Consider whether to use decorator vs ABC for registering -- seems its always single function? Better to keep pattern
        3. Cleanup HOPF nested functions, its messy
        4. Add unit tests
        5. Decide on toml schema and validation
        6. Add to runner and results


2. Add documention (the how to's in README
----------

------------------
8. Import legacy data
-----------------
4. Add plotter helpers

5. Add PR helper -> do not persist results
   Two types of PRs
    PR in ucc-bench repo (updating something about benchmark code)
      run benchmarks on changest in PR and compare to results for prior commit
    PR in ucc repo (updating something about UCC)
      create a version of this repo that uses pre-release version of UCC (specific hash)
      do the same as above

--- Demo here
3. Add reporter that converts to flat view of performance
6. Add github actions
7. Run in parallel with main repo, then switch when ready



------- work out versionion and hash ------------

benchmark results -> per set of compilers
  hash of ucc-bench PR => set of compilers

So at any point in time, ucc-bench is pointing to specific hash/tag release for UCC dependency
1. When merge to main in UCC -> downstream kicks-off PR to update benchmark results to hash of that version, auto-commits results
2. When open a PR in UCC -> nothing is commited back, but downstream runs comparision, assumes ancestor hash is in ucc-bench results history
   Does diff -> how to look up ancestor hash?
3. When open a PR in ucc-bench, e.g. upgrade another compiler version -> opens PR (for review) that includes benchmark changes

What is ordering for plots over time
  date
What is most recent/latest?

any other change to benchmarks (adding circuit, output) is a new version/set of results


ucc-bench <> not ok to fail
hash (commit on main)-> compiler versions, benchmark configs, etc.
 -> properly time-ordered, can do by time

ucc PR <> ok if fails
only have ucc hash/versions, how do I lookup my ancestor PR
  -> secondary index? ucc version hash -> version of ucc-bench with those results
